"""
Tests for gui_auxiliary.py AuxiliaryMixin functionality.
"""

import json
import tkinter as tk
from datetime import datetime
from unittest.mock import MagicMock, Mock, call, patch

import pytest

from gui_auxiliary import AuxiliaryMixin


class TestAuxiliaryMixin:
    """Test cases for AuxiliaryMixin functionality."""

    @pytest.fixture
    def mock_gui(self):
        """Create a mock GUI instance with AuxiliaryMixin."""
        mock = Mock(spec=AuxiliaryMixin)
        mock.config = {
            "vendor_id": 0x1234,
            "product_id": 0x5678,
            "device_settings": {},
            "log_level_filter": "INFO",
        }
        
        # Device attributes
        mock.dock = Mock()
        mock._is_device_connected = True
        
        # GUI elements
        mock.log_text = Mock()
        mock.log_text.insert = Mock()
        mock.log_text.delete = Mock()
        mock.log_text.see = Mock()
        mock.log_text.tag_config = Mock()
        mock.log_text.tag_add = Mock()
        mock.log_text.yview_moveto = Mock()
        mock.log_level_filter = Mock()
        mock.log_level_filter.get = Mock(return_value="INFO")
        mock.status_bar = Mock()
        mock.after = Mock()
        mock.logger = Mock()
        mock._apply_appearance_mode_theme_color = Mock(return_value="#ffffff")
        
        # Settings
        mock._save_config = Mock()
        mock._show_error = Mock()
        
        # Log history
        mock.log_history = []
        
        return mock

    @pytest.fixture
    def mock_settings_dialog(self):
        """Create a mock settings dialog."""
        dialog = Mock()
        dialog.winfo_exists = Mock(return_value=True)
        dialog.destroy = Mock()
        return dialog

    @pytest.fixture
    def mock_usb_devices(self):
        """Create mock USB device list."""
        return [
            {
                "idVendor": 0x1234,
                "idProduct": 0x5678,
                "iManufacturer": "Test Manufacturer",
                "iProduct": "Test Device",
                "bus": 1,
                "address": 2,
            },
            {
                "idVendor": 0xABCD,
                "idProduct": 0xEF01,
                "iManufacturer": "Other Manufacturer",
                "iProduct": "Other Device",
                "bus": 2,
                "address": 3,
            },
        ]

    @pytest.mark.unit
    def test_open_settings_window(self, mock_gui):
        """Test opening settings window."""
        with patch("settings_window.SettingsDialog") as mock_dialog_class:
            mock_dialog = Mock()
            mock_dialog_class.return_value = mock_dialog
            
            AuxiliaryMixin.open_settings_window(mock_gui)
            
            # Should create settings dialog
            mock_dialog_class.assert_called_once()
            mock_dialog.mainloop.assert_called_once()

    @pytest.mark.unit
    def test_update_default_progressbar_colors(self, mock_gui):
        """Test updating progressbar colors."""
        with patch("customtkinter.CTkProgressBar") as mock_progressbar_class:
            mock_progressbar = Mock()
            mock_progressbar_class.return_value = mock_progressbar
            
            AuxiliaryMixin._update_default_progressbar_colors(mock_gui)
            
            # Should configure progressbar
            mock_progressbar.configure.assert_called()

    @pytest.mark.unit
    def test_update_log_colors_gui(self, mock_gui):
        """Test updating log colors in GUI."""
        AuxiliaryMixin.update_log_colors_gui(mock_gui)
        
        # Should update log text tag colors
        mock_gui.log_text.tag_config.assert_called()

    @pytest.mark.unit
    def test_update_log_text_area_tag_colors(self, mock_gui):
        """Test updating log text area tag colors."""
        AuxiliaryMixin._update_log_text_area_tag_colors(
            mock_gui,
            info_color="#00FF00",
            warning_color="#FFFF00",
            error_color="#FF0000",
            debug_color="#0000FF",
        )
        
        # Should configure all log level tags
        assert mock_gui.log_text.tag_config.call_count >= 4
        tag_calls = [call[0][0] for call in mock_gui.log_text.tag_config.call_args_list]
        assert "INFO" in tag_calls
        assert "WARNING" in tag_calls
        assert "ERROR" in tag_calls
        assert "DEBUG" in tag_calls

    @pytest.mark.unit
    def test_get_device_display_info(self, mock_gui, mock_usb_devices):
        """Test getting device display info."""
        device = mock_usb_devices[0]
        
        result = AuxiliaryMixin._get_device_display_info(mock_gui, device)
        
        assert "Test Manufacturer" in result
        assert "Test Device" in result
        assert "1234:5678" in result

    @pytest.mark.unit
    def test_update_settings_device_combobox(self, mock_gui, mock_usb_devices):
        """Test updating device combobox in settings."""
        mock_combobox = Mock()
        mock_combobox.configure = Mock()
        mock_combobox.set = Mock()
        mock_combobox.get = Mock(return_value="")
        
        parent_window = Mock()
        parent_window.device_combobox = mock_combobox
        
        AuxiliaryMixin._update_settings_device_combobox(
            mock_gui, mock_usb_devices, parent_window, True, None
        )
        
        # Should update combobox values
        mock_combobox.configure.assert_called()
        # Should set current device as selected
        mock_combobox.set.assert_called()

    @pytest.mark.unit
    def test_on_settings_dialog_close(self, mock_gui, mock_settings_dialog):
        """Test settings dialog close handler."""
        mock_gui._active_settings_dialog = mock_settings_dialog
        
        AuxiliaryMixin._on_settings_dialog_close(mock_gui, mock_settings_dialog)
        
        # Should destroy dialog and clear reference
        mock_settings_dialog.destroy.assert_called_once()
        assert mock_gui._active_settings_dialog is None

    @pytest.mark.unit
    def test_scan_usb_devices_for_settings(self, mock_gui, mock_usb_devices):
        """Test USB device scanning for settings."""
        with patch("usb.core.find", return_value=mock_usb_devices):
            mock_window = Mock()
            mock_callback = Mock()
            
            AuxiliaryMixin.scan_usb_devices_for_settings(
                mock_gui, mock_window, True, mock_callback
            )
            
            # Should call update method via after
            mock_gui.after.assert_called()

    @pytest.mark.unit
    def test_apply_device_settings_thread(self, mock_gui):
        """Test applying device settings in thread."""
        settings = {
            "test_setting": "value1",
            "another_setting": "value2",
        }
        
        mock_gui.dock.apply_setting = Mock(return_value=True)
        
        AuxiliaryMixin._apply_device_settings_thread(mock_gui, settings)
        
        # Should apply each setting
        assert mock_gui.dock.apply_setting.call_count == 2
        # Should update status
        mock_gui.status_bar.configure.assert_called()

    @pytest.mark.unit
    def test_apply_device_settings_from_dialog(self, mock_gui):
        """Test applying device settings from dialog."""
        settings = {"setting1": "value1"}
        
        with patch("threading.Thread") as mock_thread_class:
            mock_thread = Mock()
            mock_thread_class.return_value = mock_thread
            
            AuxiliaryMixin.apply_device_settings_from_dialog(mock_gui, settings)
            
            # Should start thread
            mock_thread_class.assert_called_once()
            mock_thread.start.assert_called_once()

    @pytest.mark.unit
    def test_log_to_gui_widget(self, mock_gui):
        """Test logging to GUI widget."""
        mock_gui.log_history = []
        
        AuxiliaryMixin.log_to_gui_widget(mock_gui, "Test message", "INFO")
        
        # Should add to log history
        assert len(mock_gui.log_history) == 1
        assert mock_gui.log_history[0]["message"] == "Test message"
        assert mock_gui.log_history[0]["level"] == "INFO"
        
        # Should schedule GUI update
        mock_gui.after.assert_called()

    @pytest.mark.unit
    def test_log_filtering(self, mock_gui):
        """Test log level filtering."""
        mock_gui.log_history = [
            {"timestamp": datetime.now(), "level": "DEBUG", "message": "Debug msg"},
            {"timestamp": datetime.now(), "level": "INFO", "message": "Info msg"},
            {"timestamp": datetime.now(), "level": "WARNING", "message": "Warning msg"},
            {"timestamp": datetime.now(), "level": "ERROR", "message": "Error msg"},
        ]
        
        # Filter set to INFO - should show INFO, WARNING, ERROR but not DEBUG
        mock_gui.log_level_filter.get.return_value = "INFO"
        
        AuxiliaryMixin.on_gui_log_filter_change(mock_gui, None)
        
        # Should clear and repopulate log
        mock_gui.log_text.delete.assert_called_with("1.0", "end")
        # Should insert 3 messages (INFO, WARNING, ERROR)
        assert mock_gui.log_text.insert.call_count == 3

    @pytest.mark.unit
    def test_clear_log_gui(self, mock_gui):
        """Test clearing log GUI."""
        mock_gui.log_history = [
            {"timestamp": datetime.now(), "level": "INFO", "message": "Test"},
        ]
        
        AuxiliaryMixin.clear_log_gui(mock_gui)
        
        # Should clear log history and text
        assert mock_gui.log_history == []
        mock_gui.log_text.delete.assert_called_with("1.0", "end")

    @pytest.mark.unit
    def test_download_gui_logs(self, mock_gui):
        """Test downloading GUI logs."""
        mock_gui.log_history = [
            {
                "timestamp": datetime(2024, 1, 1, 12, 0, 0),
                "level": "INFO",
                "message": "Test log entry",
            }
        ]
        
        with patch("tkinter.filedialog.asksaveasfilename", return_value="/test/logs.txt"):
            with patch("builtins.open", create=True) as mock_open:
                mock_file = Mock()
                mock_open.return_value.__enter__.return_value = mock_file
                
                AuxiliaryMixin.download_gui_logs(mock_gui)
                
                # Should write logs to file
                mock_file.write.assert_called()
                written_content = mock_file.write.call_args[0][0]
                assert "2024-01-01" in written_content
                assert "INFO" in written_content
                assert "Test log entry" in written_content

    @pytest.mark.unit
    def test_download_gui_logs_cancelled(self, mock_gui):
        """Test cancelled log download."""
        with patch("tkinter.filedialog.asksaveasfilename", return_value=""):
            AuxiliaryMixin.download_gui_logs(mock_gui)
            
            # Should not attempt to write file
            mock_gui.logger.info.assert_not_called()

    @pytest.mark.unit
    def test_log_level_hierarchy(self, mock_gui):
        """Test log level filtering hierarchy."""
        log_levels = {
            "DEBUG": 0,
            "INFO": 1,
            "WARNING": 2,
            "ERROR": 3,
        }
        
        mock_gui.log_history = [
            {"timestamp": datetime.now(), "level": level, "message": f"{level} message"}
            for level in log_levels.keys()
        ]
        
        # Test each filter level
        for filter_level, filter_value in log_levels.items():
            mock_gui.log_level_filter.get.return_value = filter_level
            mock_gui.log_text.insert.reset_mock()
            
            AuxiliaryMixin.on_gui_log_filter_change(mock_gui, None)
            
            # Should show messages at or above filter level
            expected_count = len([l for l, v in log_levels.items() if v >= filter_value])
            assert mock_gui.log_text.insert.call_count == expected_count

    @pytest.mark.integration
    def test_settings_workflow(self, mock_gui, mock_usb_devices):
        """Test complete settings workflow."""
        # Mock USB devices
        with patch("usb.core.find", return_value=mock_usb_devices):
            # Open settings
            with patch("settings_window.SettingsDialog") as mock_dialog_class:
                mock_dialog = Mock()
                mock_dialog_class.return_value = mock_dialog
                
                AuxiliaryMixin.open_settings_window(mock_gui)
                
                # Apply settings
                settings = {"setting1": "value1"}
                mock_gui.dock.apply_setting = Mock(return_value=True)
                
                AuxiliaryMixin._apply_device_settings_thread(mock_gui, settings)
                
                # Close dialog
                mock_gui._active_settings_dialog = mock_dialog
                AuxiliaryMixin._on_settings_dialog_close(mock_gui, mock_dialog)
                
                # Verify workflow
                assert mock_dialog_class.called
                assert mock_gui.dock.apply_setting.called
                assert mock_gui._active_settings_dialog is None