"""
Tests for gui_actions_file.py FileActionsMixin functionality.
"""

import os
import threading
from unittest.mock import MagicMock, Mock, call, patch

import pytest

from gui_actions_file import FileActionsMixin


class TestFileActionsMixin:
    """Test cases for FileActionsMixin functionality."""

    @pytest.fixture
    def mock_gui(self):
        """Create a mock GUI instance with FileActionsMixin."""
        mock = Mock(spec=FileActionsMixin)
        mock.config = {
            "download_directory": "/test/downloads",
            "google_api_key": "test_api_key",
        }
        mock.download_directory = "/test/downloads"
        mock.dock = Mock()
        mock._is_device_connected = True
        
        # GUI elements
        mock.file_tree = Mock()
        mock.file_tree.selection.return_value = []
        mock.file_tree.item.return_value = {}
        mock.file_tree.set = Mock()
        mock.status_bar = Mock()
        mock.logger = Mock()
        
        # File operations manager
        mock.file_operations_manager = Mock()
        mock.file_operations_manager.download_file = Mock()
        mock.file_operations_manager.delete_file = Mock()
        mock.file_operations_manager.cancel_download = Mock()
        mock.file_operations_manager.cancel_all_downloads = Mock()
        mock.file_operations_manager.get_active_downloads = Mock(return_value=[])
        
        # Methods
        mock.after = Mock()
        mock._show_error = Mock()
        mock._update_file_status_in_treeview = Mock()
        mock._remove_file_from_treeview = Mock()
        mock._update_gui_file_counts_only = Mock()
        
        return mock

    @pytest.fixture
    def mock_file_data(self):
        """Create mock file data."""
        return {
            "values": [
                "test.wav",          # filename
                "Not Downloaded",    # status
                "10.5s",            # duration
                "1024 KB",          # size
                "2024-01-01",       # date
                "/device/test.wav", # device_path
            ]
        }

    @pytest.mark.unit
    def test_get_local_filepath(self, mock_gui):
        """Test getting local file path."""
        result = FileActionsMixin._get_local_filepath(mock_gui, "test file.wav")
        assert result == "/test/downloads/test_file.wav"
        
        # Test with special characters
        result = FileActionsMixin._get_local_filepath(mock_gui, "test:file\\name.wav")
        assert result == "/test/downloads/test-file_name.wav"

    @pytest.mark.unit
    def test_download_selected_files_gui_no_selection(self, mock_gui):
        """Test download with no files selected."""
        mock_gui.file_tree.selection.return_value = []
        
        FileActionsMixin.download_selected_files_gui(mock_gui)
        
        # Should not attempt download
        mock_gui.file_operations_manager.download_file.assert_not_called()

    @pytest.mark.unit
    def test_download_selected_files_gui_single_file(self, mock_gui, mock_file_data):
        """Test downloading a single file."""
        mock_gui.file_tree.selection.return_value = ["item1"]
        mock_gui.file_tree.item.return_value = mock_file_data
        
        # Mock successful download operation
        mock_operation = Mock()
        mock_operation.status = "completed"
        mock_operation.progress = 100
        mock_operation.error = None
        mock_gui.file_operations_manager.download_file.return_value = mock_operation
        
        FileActionsMixin.download_selected_files_gui(mock_gui)
        
        # Should start download
        mock_gui.file_operations_manager.download_file.assert_called_once()
        # Should update UI
        mock_gui._update_file_status_in_treeview.assert_called()

    @pytest.mark.unit
    def test_download_selected_files_gui_multiple_files(self, mock_gui, mock_file_data):
        """Test downloading multiple files."""
        mock_gui.file_tree.selection.return_value = ["item1", "item2", "item3"]
        mock_gui.file_tree.item.return_value = mock_file_data
        
        mock_operation = Mock()
        mock_operation.status = "downloading"
        mock_gui.file_operations_manager.download_file.return_value = mock_operation
        
        FileActionsMixin.download_selected_files_gui(mock_gui)
        
        # Should start downloads for all files
        assert mock_gui.file_operations_manager.download_file.call_count == 3

    @pytest.mark.unit
    def test_download_already_downloaded_file(self, mock_gui, mock_file_data):
        """Test attempting to download already downloaded file."""
        mock_file_data["values"][1] = "Downloaded"  # Set status to Downloaded
        mock_gui.file_tree.selection.return_value = ["item1"]
        mock_gui.file_tree.item.return_value = mock_file_data
        
        FileActionsMixin.download_selected_files_gui(mock_gui)
        
        # Should skip download
        mock_gui.file_operations_manager.download_file.assert_not_called()

    @pytest.mark.unit
    def test_delete_selected_files_gui(self, mock_gui, mock_file_data):
        """Test deleting selected files."""
        mock_gui.file_tree.selection.return_value = ["item1", "item2"]
        mock_gui.file_tree.item.return_value = mock_file_data
        
        with patch("tkinter.messagebox.askyesno", return_value=True):
            mock_operation = Mock()
            mock_operation.status = "completed"
            mock_operation.error = None
            mock_gui.file_operations_manager.delete_file.return_value = mock_operation
            
            FileActionsMixin.delete_selected_files_gui(mock_gui)
            
            # Should delete files
            assert mock_gui.file_operations_manager.delete_file.call_count == 2
            # Should remove from treeview
            assert mock_gui._remove_file_from_treeview.call_count == 2

    @pytest.mark.unit
    def test_delete_selected_files_cancelled(self, mock_gui, mock_file_data):
        """Test cancelling file deletion."""
        mock_gui.file_tree.selection.return_value = ["item1"]
        mock_gui.file_tree.item.return_value = mock_file_data
        
        with patch("tkinter.messagebox.askyesno", return_value=False):
            FileActionsMixin.delete_selected_files_gui(mock_gui)
            
            # Should not delete
            mock_gui.file_operations_manager.delete_file.assert_not_called()

    @pytest.mark.unit
    def test_update_operation_progress(self, mock_gui):
        """Test updating operation progress."""
        operation = Mock()
        operation.file_id = "item1"
        operation.status = "downloading"
        operation.progress = 50
        operation.error = None
        
        FileActionsMixin._update_operation_progress(mock_gui, operation)
        
        # Should schedule GUI update
        mock_gui.after.assert_called_with(0, mock_gui._perform_gui_update_for_operation, operation)

    @pytest.mark.unit
    def test_perform_gui_update_for_operation_downloading(self, mock_gui):
        """Test GUI update for downloading operation."""
        operation = Mock()
        operation.file_id = "item1"
        operation.status = "downloading"
        operation.progress = 75
        operation.operation_type = "download"
        
        FileActionsMixin._perform_gui_update_for_operation(mock_gui, operation)
        
        # Should update status in treeview
        mock_gui.file_tree.set.assert_called_with("item1", "Status", "Downloading... 75%")

    @pytest.mark.unit
    def test_perform_gui_update_for_operation_completed(self, mock_gui):
        """Test GUI update for completed operation."""
        operation = Mock()
        operation.file_id = "item1"
        operation.status = "completed"
        operation.operation_type = "download"
        operation.local_path = "/test/downloads/test.wav"
        
        FileActionsMixin._perform_gui_update_for_operation(mock_gui, operation)
        
        # Should update status to Downloaded
        mock_gui._update_file_status_in_treeview.assert_called_with(
            "item1", "Downloaded", ["downloaded"]
        )

    @pytest.mark.unit
    def test_perform_gui_update_for_operation_error(self, mock_gui):
        """Test GUI update for failed operation."""
        operation = Mock()
        operation.file_id = "item1"
        operation.status = "failed"
        operation.error = "Connection lost"
        operation.operation_type = "download"
        
        FileActionsMixin._perform_gui_update_for_operation(mock_gui, operation)
        
        # Should show error status
        mock_gui.file_tree.set.assert_called_with("item1", "Status", "Error: Connection lost")

    @pytest.mark.unit
    def test_transcribe_selected_audio_gemini(self, mock_gui, mock_file_data):
        """Test audio transcription with Gemini."""
        mock_file_data["values"][1] = "Downloaded"  # File is downloaded
        mock_gui.file_tree.item.return_value = mock_file_data
        mock_gui._get_local_filepath.return_value = "/test/downloads/test.wav"
        
        with patch("os.path.exists", return_value=True):
            with patch("threading.Thread") as mock_thread_class:
                mock_thread = Mock()
                mock_thread_class.return_value = mock_thread
                
                FileActionsMixin._transcribe_selected_audio_gemini(mock_gui, "item1")
                
                # Should start transcription thread
                mock_thread_class.assert_called_once()
                mock_thread.start.assert_called_once()

    @pytest.mark.unit
    def test_transcribe_not_downloaded_file(self, mock_gui, mock_file_data):
        """Test attempting to transcribe non-downloaded file."""
        mock_file_data["values"][1] = "Not Downloaded"
        mock_gui.file_tree.item.return_value = mock_file_data
        
        FileActionsMixin._transcribe_selected_audio_gemini(mock_gui, "item1")
        
        # Should show error
        mock_gui._show_error.assert_called()

    @pytest.mark.unit
    def test_transcription_worker(self, mock_gui):
        """Test transcription worker thread."""
        mock_results = {
            "transcription": "Test transcription",
            "insights": "Test insights",
        }
        
        with patch("transcription_module.process_audio_file_for_insights", return_value=mock_results):
            mock_gui._on_transcription_complete = Mock()
            
            FileActionsMixin._transcription_worker(
                mock_gui, "/test/audio.wav", "api_key", "audio.wav"
            )
            
            # Should call completion handler
            mock_gui.after.assert_called()

    @pytest.mark.unit
    def test_on_transcription_complete(self, mock_gui):
        """Test transcription completion handler."""
        results = {
            "transcription": "Test transcription text",
            "insights": "Test insights data",
        }
        
        with patch("tkinter.messagebox.showinfo") as mock_showinfo:
            FileActionsMixin._on_transcription_complete(mock_gui, results, "test.wav")
            
            # Should show results dialog
            mock_showinfo.assert_called_once()
            call_args = mock_showinfo.call_args[0]
            assert "test.wav" in call_args[0]
            assert "Test transcription text" in call_args[1]

    @pytest.mark.unit
    def test_cancel_all_downloads_gui(self, mock_gui):
        """Test cancelling all downloads."""
        mock_downloads = [
            Mock(file_id="item1", filename="file1.wav"),
            Mock(file_id="item2", filename="file2.wav"),
        ]
        mock_gui.file_operations_manager.get_active_downloads.return_value = mock_downloads
        
        with patch("tkinter.messagebox.askyesno", return_value=True):
            FileActionsMixin.cancel_all_downloads_gui(mock_gui)
            
            # Should cancel all downloads
            mock_gui.file_operations_manager.cancel_all_downloads.assert_called_once()
            # Should update status
            assert mock_gui.file_tree.set.call_count == 2

    @pytest.mark.unit
    def test_cancel_selected_downloads_gui(self, mock_gui):
        """Test cancelling selected downloads."""
        mock_gui.file_tree.selection.return_value = ["item1", "item2"]
        mock_downloads = [
            Mock(file_id="item1", filename="file1.wav"),
            Mock(file_id="item2", filename="file2.wav"),
            Mock(file_id="item3", filename="file3.wav"),
        ]
        mock_gui.file_operations_manager.get_active_downloads.return_value = mock_downloads
        
        FileActionsMixin.cancel_selected_downloads_gui(mock_gui)
        
        # Should cancel only selected downloads
        assert mock_gui.file_operations_manager.cancel_download.call_count == 2
        # Should update status
        assert mock_gui.file_tree.set.call_count == 2

    @pytest.mark.unit
    def test_no_active_downloads_to_cancel(self, mock_gui):
        """Test cancelling when no downloads active."""
        mock_gui.file_operations_manager.get_active_downloads.return_value = []
        
        with patch("tkinter.messagebox.showinfo") as mock_showinfo:
            FileActionsMixin.cancel_all_downloads_gui(mock_gui)
            
            # Should show info message
            mock_showinfo.assert_called_once()

    @pytest.mark.integration
    def test_full_download_workflow(self, mock_gui, mock_file_data):
        """Test complete download workflow."""
        mock_gui.file_tree.selection.return_value = ["item1"]
        mock_gui.file_tree.item.return_value = mock_file_data
        
        # Mock download operation
        mock_operation = Mock()
        mock_operation.file_id = "item1"
        mock_operation.status = "downloading"
        mock_operation.progress = 0
        mock_operation.operation_type = "download"
        mock_gui.file_operations_manager.download_file.return_value = mock_operation
        
        # Start download
        FileActionsMixin.download_selected_files_gui(mock_gui)
        
        # Simulate progress updates
        mock_operation.progress = 50
        FileActionsMixin._perform_gui_update_for_operation(mock_gui, mock_operation)
        
        # Simulate completion
        mock_operation.status = "completed"
        mock_operation.progress = 100
        mock_operation.local_path = "/test/downloads/test.wav"
        FileActionsMixin._perform_gui_update_for_operation(mock_gui, mock_operation)
        
        # Verify UI updates
        assert mock_gui.file_tree.set.called
        assert mock_gui._update_file_status_in_treeview.called